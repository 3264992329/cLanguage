/*题目 2658: 蓝桥杯2022年第十三届省赛真题-X进制减法
时间限制: 3s 内存限制: 320MB 提交: 10331 解决: 2191
题目描述
进制规定了数字在数位上逢几进一。

X 进制是一种很神奇的进制，因为其每一数位的进制并不固定！例如说某种 X 进制数，最低数位为二进制，第二数位为十进制，第三数位为八进制，则 X 进制数 321 转换为十进制数为 65。

现在有两个 X 进制表示的整数 A 和 B，但是其具体每一数位的进制还不确定，只知道 A 和 B 是同一进制规则，且每一数位最高为 N 进制，最低为二进制。请你算出 A ? B 的结果最小可能是多少。

请注意，你需要保证 A 和 B 在 X 进制下都是合法的，即每一数位上的数字要小于其进制。 

输入格式
第一行一个正整数 N，含义如题面所述。

第二行一个正整数 Ma，表示 X 进制数 A 的位数。

第三行 Ma 个用空格分开的整数，表示 X 进制数 A 按从高位到低位顺序各个数位上的数字在十进制下的表示。

第四行一个正整数 Mb，表示 X 进制数 B 的位数。

第五行 Mb 个用空格分开的整数，表示 X 进制数 B 按从高位到低位顺序各个数位上的数字在十进制下的表示。

请注意，输入中的所有数字都是十进制的。

输出格式
输出一行一个整数，表示 X 进制数 A ? B 的结果的最小可能值转换为十进制后再模 1000000007 的结果。 
样例输入
11
3
10 4 0
3
1 2 0
样例输出
94*/
#include<stdio.h>
int main(){
	//最高为N进制
	int n,ma,mb;
	scanf("%d",&n);
	//第一个数为ma位数
	scanf("%d",&ma);
	int a[ma];
	for(int i=0;i<ma;i++){
		scanf("%d",&a[ma-i-1]);
	}
	
	// 第二个数为mb位数
	scanf("%d",&mb);
	int b[mb];
	for(int i=0;i<mb;i++){
		scanf("%d",&b[mb-i-1]);
	}
	
	int suma=a[0],sumb=b[0];
	int min=0;
	
	int  t[999999];
	for(int i=0;i<(ma>mb)?ma:mb;i++){
		if(a[i]>b[i]){
			t[i]=a[i]+1;
		}else{
			t[i]=b[i]+1;
		}
	}
	
	int ta[999999];
	ta[0]=t[0];
	for(int i=1;i<ma;i++){
		suma=suma+a[i]*ta[i-1];
		ta[i]=ta[i]*ta[i-1];
	}
	
	int tb[999999];
	tb[0]=t[0];
	for(int i=1;i<mb;i++){
		sumb=sumb+b[i]*tb[i-1];
		tb[i]=tb[i]*tb[i-1];
	}
	
	int con=suma-sumb;
	if(con>0){
		printf("%d",con);
	}else{
		printf("%d",-con);
	}
	
	return 0;
}
